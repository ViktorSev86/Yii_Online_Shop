<?php

namespace app\components;

use yii\base\Widget;
use app\models\Category;

// Виджет левого бокового меню
class MenuWidget extends Widget
{

    public $tpl; // Свойство шаблон: чтобы виджет стал универсальным и смог работать более, чем с одним шаблоном (например не только в пользовательской части, но и в админовской части, где вид (шаблон) меню может быть другим)
    public $ul_class; // Свойство - css-класс, который мы присвоим меню (например внешний вид (то есть css-стили) в пользовательской и админовской части может отличаться)
    public $data; // В это свойство будем получать массив всех категорий из таблицы в БД
    public $tree; // В этом свойстве мы будем формировать полученных категорий дерево, используя специальный метод
    public $menuHtml; // В этом свойстве будет готовая вёрстка нашего меню, которую будет возвращать метод run
    public $model;
    public $cache_time; // Время, на которое нужно кэшировать меню. Для пользовательской части задаём 60 секунд. Для админки не нужно, поэтому будет 0.

    public function init()
    {
        parent::init();
        // Производим нормализацию свойств 
        if($this->ul_class === null) {
            $this->ul_class = 'menu'; // Если класс не передан, устанавливаем класс по-умолчанию
        }
        if($this->tpl === null) {
            $this->tpl = 'menu'; // Если шаблон не передан, задаём шаблон по-умолчанию
        }
        $this->tpl .= '.php'; // Добавляем расширение к имени шаблона

    }

    public function run()
    {
        //$this->data = Category::find()->indexBy('id')->asArray()->all(); // Получаем все категории из таблицы Category базы данных в виде массива массивов (массив массивов работает быстрее и использует меньше ресурсов, чем массив объектов). Метод indexBy('id') задаёт id из таблицы Category в качестве индексов элементов массива массивов (это не обязательно, но удобно в работе).
        //debug($this->data); // Выводим массив объектов из таблицы Category для проверки
        if($this->cache_time) { // Если время кэширования не равно 0, получаем из кэша, иначе из БД.
            $menu = \Yii::$app->cache->get('menu'); // Получим данные из кэша, чтобы сэкономить ресурсы (не обращаться в БД и не верстать меню при каждой перезагрузке страницы)
            if($menu) { // Если данные меню их кэша получено, возвращаем его
                return $menu;
            }
        }
        $this->data = Category::find()->select('id, parent_id, title')->indexBy('id')->asArray()->all(); // В методе select выбираем только те колонки из таблицы, которые нам необходимо достать (мы указали параметр в виде строки, альтернативно можно указать в виде массива) 
        $this->tree = $this->getTree(); // Получаем дерево категорий, используя созданный ниже метод getTree()
        $this->menuHtml = '<ul class="' . $this->ul_class . '">'; // Задаём меню класс из свойства ul_class для придания внешнего вида меню
        $this->menuHtml .= $this->getMenuHtml($this->tree); // Создаём саму вёрстку, используя метод, описанный ниже
        $this->menuHtml .= '</ul>'; // Дописываем в строку с вёрсткой закрывающий тег списка
        //debug($this->tree); // Выводим полученное дерево массивов категорий для проверки. Если мы хотим сделать один элемент вложенным во второй, нужно в таблице category базы данных (в PHPMyAdmin) у вложенного указать parent_id равным id того элемента, в который хотим его вложить.
        
        if($this->cache_time) { // Если время кэширования не равно 0, записываем в кэш.
            \Yii::$app->cache->set('menu', $this->menuHtml, $this->cache_time); // Кэшируем данные (на 60 секунд, чтобы проверить, что они берутся из кэша. Если время не указано, кэш хранится неограниченно долго. При добавлении категории необходимо предусмотреть функцию очистки кэша, чтобы новая категория появилась в меню сразу после добавления)
        }

        return $this->menuHtml; // Выводим корневые категории (пока без потомков) для проверки
        
    }

    // Метод для получения дерева категорий, позволяет делать сколько угодно уровней вложенности
    protected function getTree() { 
        $tree = [];
        foreach ($this->data as $id => &$node) {
            if (!$node['parent_id']) {
                $tree[$id] = &$node;
            } else {
                $this->data[$node['parent_id']]['children'][$node['id']] = &$node;
            }
        }
        return $tree;
    }

    // Метод проходит по дереву, берёт каждую категорию, для неё вызывает созданный ниже метод catToTemplate() - передаёт эту категорию в шаблон. Возвращает строку с готовым HTML-кодом
    protected function getMenuHtml($tree, $tab='') { // Свойство tree передаётся в виде параметра (а не используется просто в виде свойства), потому что мы будем вызывать рекурсивно из шаблона в методе catToTemplate() не всё дерево, а каждую конкретную категорию этого дерева. Параметр tab - это отступ (для самостоятельных категорий равен пустой строке).
        $str = '';
        foreach ($tree as $category) {
            $str .= $this->catToTemplate($category, $tab);
        }
        return $str;
    }

    // Метод получает категорию, включает буферизацию вывода и подключать шаблон из свойства template и возвращать результат из буфера
    protected function catToTemplate($category, $tab) { 
        ob_start(); // Включаем буферизацию ввода (чтобы ничего не выводилось на экран)
        include __DIR__ . '/menu_tpl/' . $this->tpl; // Подключаем шаблона из свойства tpl, в котором прописана вёрстка для каждой категории. Здесь нам не нужно рендерить виды, мы просто используем шаблон, чтобы запихнуть в него каждую конкретную категорию и вернуть её уже обёрнутой
        return ob_get_clean(); // Возвращаем результат из буфера
    }

}